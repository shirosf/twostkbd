#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# Copyright (C) 2024 Shiro Ninomiya
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see
# <https://www.gnu.org/licenses/old-licenses/gpl-2.0.html>.
#
import sys
import os
import logging
parent_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
sys.path.append(parent_dir)
from twostkbd import KbdConfig

logger=logging.getLogger("gen_header")
logger.setLevel(logging.DEBUG)

class ArduinoKbdConfig(KbdConfig):
    KeyGpio=["k0", "k1", "k2", "k3", "k4", "k5",
             "f1", "f2", "f3",
             "alt", "ctrl", "shift", "ext"]
    KeyCode={"BS":"BACKSPACE", "SP":"SPACE", "RET":"RETURN",
             "LEFT":"LEFT_ARROW",
             "RIGHT":"RIGHT_ARROW",
             "UP":"UP_ARROW",
             "DOWN":"DOWN_ARROW",
             "PUP":"PAGE_UP",
             "PDOWN":"PAGE_DOWN",
             }
    KeySeq={"CHOME","CEND","CLEFT","CRIGHT","CTLG",
             "CTLC","CTLX","ALTX","CTL_SLASH",
            }


class PrintHeader():
    def __init__(self, kbdconfig, outfd=sys.stdout):
        self.outfd=outfd
        self.kbdconfig=kbdconfig

    def file_head(self, fname: str):
        self.outfd.write("/*\n")
        self.outfd.write("This file is automatically generated.\n")
        self.outfd.write("Don't edit this file.\n")
        self.outfd.write("*/\n")
        self.outfd.write("#ifndef %s_H_\n" % fname.upper())
        self.outfd.write("#define %s_H_\n" % fname.upper())
        self.outfd.write("\n")
        self.outfd.write("#ifndef PCRUN_MODE\n")
        self.outfd.write("#include \"USBHIDKeyboard.h\"\n")
        self.outfd.write("#endif\n")

    def file_bottom(self):
        self.outfd.write("\n")
        self.outfd.write("#endif\n")

    def gpio_map(self):
        self.outfd.write("\n")
        self.outfd.write("#define KEY_GPIO_LIST {")
        for gn in ArduinoKbdConfig.KeyGpio:
            self.outfd.write("%s," % self.kbdconfig.argpios[gn])
        self.outfd.write("}\n")
        self.outfd.write("\n")
        self.outfd.write('''
typedef enum {
	MODKEY_A=0,
	MODKEY_C,
	MODKEY_S,
	MODKEY_E,
	MODKEY_END,
} modkey_enum_t;
''')
        self.outfd.write("\n")


    def keycode_enum(self, symbols):
        self.outfd.write("#ifdef PCRUN_MODE\n")
        self.outfd.write("enum {\n")
        for i,s in enumerate(symbols):
            self.outfd.write("\t%s, // %d\n" % (s, i))
        self.outfd.write("};\n")
        self.outfd.write("\n")
        self.outfd.write("#else\n")
        for s in symbols:
            d=s.replace("KEYCODE_", "")
            if d in ArduinoKbdConfig.KeyCode:
                d="KEY_" + ArduinoKbdConfig.KeyCode[d]
            elif d in ArduinoKbdConfig.KeySeq:
                d="KEYSEQ_" + d
            elif d!="0": d="KEY_" + d
            self.outfd.write("#define %s %s\n" % (s, d))
        self.outfd.write("\n")
        self.outfd.write("enum {\n")
        self.outfd.write("\tKEYSEQ_START=0x100,\n")
        for s in ArduinoKbdConfig.KeySeq:
            self.outfd.write("\tKEYSEQ_%s,\n" % s)
        self.outfd.write("};\n")
        self.outfd.write("\n")
        self.outfd.write("#endif\n")

    def data_struct(self):
        self.outfd.write("typedef struct regk_data{\n")
        self.outfd.write("\tuint8_t rk;\n")
        self.outfd.write("\tuint8_t mks[MODKEY_END];\n")
        self.outfd.write("} regk_data_t;\n")
        self.outfd.write("\n")
        self.outfd.write("extern regk_data_t skey_table[];\n")
        self.outfd.write("extern regk_data_t fkey_table[];\n")
        self.outfd.write("extern uint16_t mkey_table[][2];\n")
        self.outfd.write("\n")

class PrintSource():
    def __init__(self, kbdconfig, outfd=sys.stdout):
        self.outfd=outfd
        self.kbdconfig=kbdconfig
        self.kbdconfig.skeytable.sort(key=lambda x: (x["1st"], x["2nd"]))
        self.keycode_symbols=["KEYCODE_0", "KEYCODE_LEFT_ALT",
                              "KEYCODE_LEFT_CTRL", "KEYCODE_LEFT_SHIFT"]

    def file_head(self):
        self.outfd.write("/*\n")
        self.outfd.write("This file is automatically generated.\n")
        self.outfd.write("Don't edit this file.\n")
        self.outfd.write("*/\n")
        self.outfd.write("\n")
        self.outfd.write("#include <inttypes.h>\n")
        self.outfd.write("#include \"kbdconfig.hpp\"\n")
        self.outfd.write("#include \"fifo_queue.hpp\"\n")

    def key_tables(self):
        self.outfd.write("regk_data_t skey_table[]={\n")
        for td in self.kbdconfig.skeytable:
            m={}
            for i in ("shift", "alt", "ctrl", "ext"):
                if td["mkeys"][i]=="":
                    m[i]="0"
                elif len(td["mkeys"][i])==1:
                    if td["mkeys"][i]=="\\":
                        m[i]="'\\\\'"
                    elif td["mkeys"][i]=="'":
                        m[i]="'\\''"
                    else:
                        m[i]="'%s'" % td["mkeys"][i]
                else:
                    if td["mkeys"][i]=="VBAR":
                         m[i]="'|'"
                    else:
                        m[i]="KEYCODE_%s" % td["mkeys"][i]
                        self.keycode_symbols.append(m[i])

            self.outfd.write("\t{'%s',{%s,%s,%s,%s}},\n" % (
                td["key"], m["alt"], m["ctrl"], m["shift"], m["ext"]))
        self.outfd.write("};\n")
        self.outfd.write("\n")

    def fkey_tables(self):
        self.outfd.write("regk_data_t fkey_table[]={\n")
        for td in self.kbdconfig.fkeytable:
            m={}
            for i in ("shift", "alt", "ctrl", "ext"):
                if td["mfuncs"][i]=="":
                    m[i]="0"
                elif len(td["mkeys"][i])==1:
                    m[i]="'%s'" % td["mkeys"][i]
                else:
                    m[i]="KEYCODE_%s" % td["mkeys"][i]
                    if m[i] not in self.keycode_symbols:
                        self.keycode_symbols.append(m[i])

            fk = "KEYCODE_%s" % (td["func"] if td["func"]!="" else "0")
            if fk not in self.keycode_symbols:
                 self.keycode_symbols.append(fk)
            self.outfd.write("\t{%s,{%s,%s,%s,%s}},\n" % (
                fk, m["shift"], m["alt"], m["ctrl"], m["ext"]))

        self.outfd.write("};\n")
        self.outfd.write("\n")

    def mkey_tables(self):
        self.outfd.write("uint16_t mkey_table[][2]={\n")
        for td in self.kbdconfig.mkeytable:
            mk=td[0].replace("/", "_SLASH")
            mk="KEYCODE_%s" % mk
            if mk not in self.keycode_symbols:
                 self.keycode_symbols.append(mk)
            mbits=""
            for bk in td[1:]:
                if mbits != "" : mbits+=" | "
                mbits+="(1 << KeyFifo::KINDEX_%s)" % bk.upper()
            self.outfd.write("\t{%s,%s},\n" % (mk, mbits))
        self.outfd.write("\t{KEYCODE_0, 0},\n")
        self.outfd.write("};\n")
        self.outfd.write("\n")

if __name__ == '__main__':
    logging.basicConfig(level=logging.DEBUG)
    logger.debug("start")
    kbdconfig=ArduinoKbdConfig()
    if kbdconfig.readconf(os.path.join("..", "config.org")):
        logger.error("can't read 'config.org'")
        sys.exit(1)
    fname="kbdconfig"
    outfh=open(fname+".hpp", "w")
    outfc=open(fname+".cpp", "w")
    pheader=PrintHeader(kbdconfig, outfh)
    psource=PrintSource(kbdconfig, outfc)

    pheader.file_head(fname)
    pheader.gpio_map()

    psource.file_head()
    psource.key_tables()
    psource.fkey_tables()
    psource.mkey_tables()
    pheader.keycode_enum(psource.keycode_symbols)
    pheader.data_struct()

    pheader.file_bottom()
    outfh.close()
    outfc.close()
